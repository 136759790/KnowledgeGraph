# 隔离级别
## 没有隔离会带来的问题
### 脏读
> 一个事务中读取到另外一个事务中未提交的数据。
~~~
A向B转账500元,在一个事务中
update account set money = money+500 where name ='B'
此时其他事务利用B的账户数据进行操作，但是下边可能异常回滚，导致后者事务用的错误数据。
update account set money = money-500 where name ='A'
~~~
### 不可重复读
> 同一个事务中多次同条件查询，返回不同的数据。一个事务正在执行中，其他事务修改了本事务正在查询的数据。
### 虚读（幻读）
> 指当前事务不是独立执行时发生的现象。事务T2以插入或者修改的方式修改事务T1的结果集
~~~
事务T1批量修改表中所有记录的某一列，同时T2向数据库插入一条新数据，事务T1完成后查询还是有一行没修改。
~~~
## 隔离级别
### 未提交读
> 最宽松级别，会反生脏读、不可重复读、幻读。
### 提交读
> 能避免脏读。
### 可重复读
> 避免脏读、不可重复读。
### 串行化
> 避免脏读、不可重复读、幻读。
## 数据库支持
### MySql
> 默认隔离级别是可重复读，保证不会出现脏读和不可重复读。

修改方式：
全局修改，修改mysql.ini文件
~~~
1 #可选参数有：READ-UNCOMMITTED, READ-COMMITTED, REPEATABLE-READ, SERIALIZABLE.
2 [mysqld]
3 transaction-isolation = REPEATABLE-READ
~~~
JDBC修改方式
~~~
conn.setTransactionIsolation(conn.TRANSACTION_REPEATABLE_READ);
~~~
### Oracle
> 默认隔离级别是提交读，保证不会出现脏读。
## 数据库锁种类
### 行锁
~~~
insert/update/delete/select..for update触发行锁，粒度小，加锁慢，并发量大。Oracle和MySql默认的锁级别。
~~~
### 表锁
#### 行共享
#### 行排他
#### 共享锁
#### 共享行排他
#### 排他
> 仅允许其他事务读取该表内容，不准动。
~~~
行锁：粒度小，并发高，锁数量多，耗性能，会出现死锁。
表锁：粒度大，并发低，锁数量少，节省性能，不会出现死锁。
~~~
### 乐观锁
> 在本事务操作的时候，先加上锁，其他事务只能读不能改。
### 悲观锁
> 事务开始前读取版本号，完成后查看版本号是否一致，不一致从新取值重试。
~~~
事务修改冲突少的时候用乐观锁，冲突多的时候用悲观锁。
~~~